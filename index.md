# Text2Alpha QA System: Revolutionizing Financial Strategy Development

## Overview
The Text2Alpha, QA system is a solution designed to assist users in developing effective financial strategies. This innovative system utilizes Large Language Model to provide accurate and relevant answers to finance-related queries.

## Key Features
1. Natural Language Input: Users can input their queries in natural language, eliminating the need for technical expertise or complex syntax.
2. Contextual Understanding: The system understands the context of the query, providing relevant and accurate answers that take into account the user's specific needs and goals.

## Installation

* Clone the repository:
```bash
git clone https://github.com/neiths/Text2Alpha.git
```

* Install conda enviroment:
```bash
# Create a conda enviroment
conda env create -f environment.yml

# Activate the enviroment
conda activate text2alpha
```

## Prompt Templates

### 1. Instructions prompt
```
You are a python developer that intent to make a workable trading strategy. Your task is to create `BackTestStrategy` class that inherit from the `BaseStrategy` class given below and you MUST ONLY modify the `execute` function to follow human requirements.

Here is the `BaseStrategy` class :
'''python
import backtrader as bt

# Define a base strategy class for handling buy and sell signals and order notifications.
class BaseStrategy(bt.Strategy):
    def __init__(self, debug=True):
        """
        Initialize the strategy with parameters.

        Args:
        - debug (bool): If True, enable debug logging.

        Attributes:
        - countBuy (int): Counter for buy signals.
        - countSell (int): Counter for sell signals.
        - final_signal (int or None): Final signal for trading: 1 (long), 0 (neutral), -1 (sell).
        - debug (bool): Flag for debug mode.
        """
        self.countBuy, self.countSell = 0, 0
        self.final_signal = None
        self.debug = debug
        self.cbuy, self.csell  = 0, 0

    def log(self, txt, dt=None):
        """
        Logging function for displaying strategy events.

        Args:
        - txt (str): Text message to log.
        - dt (datetime, optional): Date and time of the log event.
        """
        if self.debug:
            dt_day = self.datas[0].datetime.date(0)
            dt_value = dt or self.datas[0].datetime.time(0)
            print("%sT%s, %s" % (dt_day, dt_value.isoformat(), txt))

    def notify_order(self, order):
        """
        Notify when an order status changes.

        Args:
        - order (backtrader.Order): Order object containing order details.
        """
        if order.status in [order.Submitted, order.Accepted]:
            return  # Ignore submitted/accepted orders

        if order.status == order.Completed:
            if order.isbuy():
                if self.countSell > 0:
                    info_trade = "CLOSE SELL"
                    self.countSell -= 1
                else:
                    info_trade = "BUY EXECUTED"
                    self.countBuy += 1
                self.log(
                    f"{info_trade}, Price: %.2f, Cost: %.2f, Comm %.2f"
                    % (
                        order.executed.price,
                        order.executed.value,
                        order.executed.comm,
                    )
                )
            else:  # Sell order executed
                if self.countBuy > 0:
                    info_trade = "CLOSE BUY"
                    self.countBuy -= 1
                else:
                    info_trade = "SELL EXECUTED"
                    self.countSell += 1
                self.log(
                    f"{info_trade}, Price: %.2f, Cost: %.2f, Comm %.2f"
                    % (
                        order.executed.price,
                        order.executed.value,
                        order.executed.comm,
                    )
                )

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log("Order Canceled/Margin/Rejected")

        self.order = None  # Reset the order attribute

    def execute(self) -> int:
        """
        Placeholder for executing trading logic.

        Returns:
        - int: Trading signal: 1 (long), 0 (neutral), -1 (sell), or None if no signal.
        """
        raise NotImplementedError

    def next(self):
        """
        Execute trading decisions based on the final signal generated by `execute()`.
        """
        self.final_signal = self.execute()
        if self.final_signal is None:
            return

        if self.final_signal > 0:  # Long signal
            if self.position:
                if self.countSell:
                    self.order = (
                        self.close()
                    )  # Close sell position if counter is set
            else:
                self.order = self.buy()  # Open buy position
                self.cbuy += 1

        elif self.final_signal < 0:  # Short signal
            if self.position:
                if self.countBuy:
                    self.order = (
                        self.close()
                    )  # Close buy position if counter is set
            else:
                self.order = self.sell()  # Open sell position
                self.csell += 1

'''
==== List indicator ====
You are provided with list of indicators and description:
Name: AroonOscillator
Alias: AroonOsc
Formula: aroonosc = aroonup - aroondown
Returns: aroonosc
Params: period (14), upperband (70), lowerband (30)

{AroonUp}, {AroonUpDown}, {AverageTrueRange}, 
{BollingerBands}, {BollingerBandsPct}, {CommodityChannelIndex}, 
{ExponentialMovingAverage}, {FibonacciPivotPoint}, {Ichimoku}, 
{Moving Average Convergence Divergence}, {MovingAverageSimple}, {ParabolicSAR}, 
{PivotPoint}, {RateOfChange}, {RelativeMomentumIndex}, 
{RelativeStrengthIndex}, {StandardDeviation}, {WilliamsR}
==================

Here are two situations you need to handle :
- SITUATION 1 : The provided list of indicators CONTAIN the indicator that human required, so you just use it follow this example :

```python
import backtrader as bt
# Define a specific strategy inheriting from `BaseStrategy` using a simple moving average indicator.
class BackTestStrategy(BaseStrategy):
    """
    Simple BackTestStrategy using Moving Average Indicator.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.sma = bt.ind.SMA(self.data.close, period=15)

    def execute(self):
        """
        Define the trading logic based on the moving average crossover.

        Returns:
        - int: Trading signal: 1 (long), -1 (sell), or None if no signal.
        """
        if self.sma > self.data.close:
            return 1  # Long signal
        elif self.sma < self.data.close:
            return -1  # Short signal
        return None  # No signal'''

- SITUATION 2 : The provided list of indicantors DO NOT CONTAIN the indicator that human required, so you try your best to create custom indicator follow this example :
```python
import backtrader as bt


class CustomIndicator(bt.Indicator):
    """"""

    lines = ("pvt",)
    params = (("period", 1),)

    def init(self):
        self.addminperiod(self.params.period)

    def next(self):
        if len(self) == 1:
            self.lines.pvt[0] = 0  # Initialize PVT at the beginning
        else:
            prev_close = self.data.close[-1]
            current_close = self.data.close[0]
            volume = self.data.volume[0]
            self.lines.pvt[0] = (
                self.lines.pvt[-1]
                + ((current_close - prev_close) / prev_close) * volume
            )


# Define a specific strategy using the custom PVT indicator
class BackTestStrategy(BaseStrategy):
    def init(self, *args, **kwargs):
        super().init(*args, **kwargs)
        # Initialize the PVT indicator
        self.pvt = PVT()

    def execute(self):
        """
        Define the trading logic based on the PVT indicator.

        Returns:

        int: Trading signal: 1 (long), -1 (sell), or None if no signal."""
        if self.pvt[0] > self.pvt[-1]:  # Example logic: if PVT is increasing
            return 1  # Long signal
        elif self.pvt[0] < self.pvt[-1]:  # Example logic: if PVT is decreasing
            return -1  # Short signal
        return None  # No signal
```

1. Hand-Crafted Prompting
```
{Instruction}
=================== 
Reasoning: let's think step by step
NOTE: If the indicator is not in the list, you can say I don't know or I can't do it.
```

2. Zero-shot CoT with DSPy Signature
```
{Instruction}
========================
Follow the following format.
Question: Query of the finance strategy.
Reasoning: Let's think step by step in order to ${produce the answer}. We ...
Answer: The ```python''' code block. Answer appears along with the reasoning.
========================
Question: {User's query}
Reasoning: Let's think step by step in order to
```

3. Few-shot CoT with DSPy
```
{Description}
======================
{DSPy Signature}
======================
Question: Develop a trading strategy that initiates a buy order when the 20-day Simple Moving Average (SMA) crosses above the 50-day Simple Moving Average (SMA) and the Relative Strength Index (RSI) is above 50 during a bullish market. Define sell conditions when the 20-day SMA crosses below the 50-day SMA and the RSI falls below 50. Reasoning: Let's think step by step in order to develop a trading strategy that meets the specified conditions. We need to create a custom strategy class that inherits from the `BaseStrategy` class. We will use the `SimpleMovingAverage` and `RelativeStrengthIndex` indicators from the provided list. Answer: 
```python 
    import backtrader as bt 
    class BackTestStrategy(BaseStrategy): 
        """ 
        Trading strategy based on SMA crossover and RSI. 
        """ 
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs) 
            self.sma_short = bt.ind.SMA(self.data.close, period=20) 
            self.sma_long = bt.ind.SMA(self.data.close, period=50) 
            self.rsi = bt.ind.RSI_SMA(self.data.close, period=14) 
            def execute(self): 
                """ 
                Define the trading logic based on SMA crossover and RSI. 
                Returns: 
                - int: Trading signal: 1 (long), -1 (sell), or None if no signal. 
                """ 
                if self.sma_short > self.sma_long and self.rsi > 50: 
                    return 1 # Long signal 
                elif self.sma_short < self.sma_long and self.rsi < 50: 
                    return -1 # Short signal return None # No signal
'''
============
Question: {query 2}
Answer:  {code block 2}
============
Question:  {query 3}
Reasoning: {rationale}
Answer: {code block 3}
============
Question: {query 4}
Answer: {code block 4}
===========
Question: {User's query}
Reasoning: Let's think step by step in order to
```




### 2. Examples of LM Assertion feedback messages

1. Common Code Generation Issues
```
<ERROR>
With the error AttributeError: 'LineBuffer' object has no attribute 'diff'.
    
This error occurs in the following function: Function name: next, params: {}
    
Error location: Line: 25.
</ERROR>

The code must avoid this error.

```

2. Indicator Recognition Errors
```
<ERROR>
With the error TypeError: MACDHisto.__init__() got an unexpected keyword argument 'fast'. 
    
This error occurs in the following function: Function name: doinit, params: {'cls': "<class 'backtrader.indicators.ma...", '_obj': '<backtrader.indicators.macd.MACD...', 'args': (), 'kwargs': "{'fast': 12, 'slow': 26, 'signal..."}}.
    
Error location: Line: 78,_obj.__init__(*args, **kwargs)
    
</ERROR>
I recommend ignoring the indicator by the Backtrader package, instead generate a custom indicator following the given descriptions.
```

3. Backtrader Package Errors
```
<ERROR>
You encountered an error from the package IndexError: array index out of range at Function name: __getitem__, params: {'ago': 0}. 
    
Error package at location: Line: 163, return self.array[self.idx + ago]. 
    
The error originates from your answer code: Function name: next, params: {} and occurs at location Line: 25, of your code answer.
</ERROR>
    
The code must avoid this error.
```

4. Lack of Indicators Interaction
```
Please review and correct the formulas and conditions. Make sure the strategy includes at least two buy or two sell signal.
```

##  Contributing
We welcome contributions! Please see our Contributing Guidelines for details.

## License
This project is licensed under the MIT License - see the LICENSE file for details.
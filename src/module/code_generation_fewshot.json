{
  "generate_result": {
    "lm": null,
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "question": "Create a trading strategy that initiates a buy order when the On-Balance Volume (OBV) trends upwards and the 10-day Exponential Moving Average (EMA) crosses above the 30-day EMA during a bullish market. Define sell conditions for when the OBV trends downwards and the 10-day EMA crosses below the 30-day EMA.",
        "feedback": "\n        With the module 'backtrader.indicators' has no attribute 'EMA_Self', I refer you ignore the indicator by Backtrader package, instead that generate custom indicator following the given descriptions.\n        ",
        "answer": "```python\nimport backtrader as bt\n\nclass CustomIndicator(bt.Indicator):\n    lines = ('ema',)\n    params = (('period', 10),)\n\n    def __init__(self):\n        self.addminperiod(self.params.period)\n\n    def next(self):\n        if len(self) == 1:\n            self.lines.ema[0] = self.data.close[0]  # Initialize EMA at the beginning\n        else:\n            self.lines.ema[0] = (self.data.close[0] * (2.0 \/ (self.params.period + 1))) + self.lines.ema[-1] * (1 - (2.0 \/ (self.params.period + 1)))\n\nclass OBV(bt.Indicator):\n    lines = ('obv',)\n    params = (('period', 1),)\n\n    def __init__(self):\n        self.addminperiod(self.params.period)\n\n    def next(self):\n        if len(self) == 1:\n            self.lines.obv[0] = 0  # Initialize OBV at the beginning\n        else:\n            if self.data.close[0] > self.data.close[-1]:\n                self.lines.obv[0] = self.lines.obv[-1] + self.data.volume[0]\n            elif self.data.close[0] < self.data.close[-1]:\n                self.lines.obv[0] = self.lines.obv[-1] - self.data.volume[0]\n            else:\n                self.lines.obv[0] = self.lines.obv[-1]\n\nclass BackTestStrategy(BaseStrategy):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Initialize the OBV indicator\n        self.obv = OBV()\n        # Initialize the EMA indicators\n        self.ema10 = CustomIndicator(period=10)\n        self.ema30 = CustomIndicator(period=30)\n\n    def execute(self):\n        \"\"\"\n        Define the trading logic based on the OBV and EMA indicators.\n\n        Returns:\n        int: Trading signal: 1 (long), -1 (sell), or None if no signal.\n        \"\"\"\n        if self.obv[0] > self.obv[-1] and self.ema10[0] > self.ema30[0]:\n            return 1  # Long signal\n        elif self.obv[0] < self.obv[-1] and self.ema10[0] < self.ema30[0]:\n            return -1  # Short signal\n        return None  # No signal\n```",
        "num_retry": 1
      },
      {
        "question": "Create a trading strategy that initiates a buy order when the Volume Weighted Average Price (VWAP) is below the current price and the 20-day EMA crosses above the 50-day EMA in a bullish market. Define sell conditions for when the VWAP is above the current price and the 20-day EMA crosses below the 50-day EMA."
      },
      {
        "question": "Develop a strategy to buy when the Ichimoku Cloud\u2019s Tenkan-sen (Conversion Line) crosses above the Kijun-sen (Base Line) and the Senkou Span A (Leading Span A) is above the Senkou Span B (Leading Span B) during a bullish market. Set sell conditions for when the Tenkan-sen crosses below the Kijun-sen and the Senkou Span A is below the Senkou Span B."
      },
      {
        "question": "Create a trading strategy that triggers a buy signal when the Moving Average Convergence Divergence (MACD) line crosses above the signal line and the Bollinger Bands show a price break above the upper band in a bullish market. Set sell conditions for when the MACD line crosses below the signal line and the price falls below the lower Bollinger Band."
      },
      {
        "question": "Design a trading strategy to buy when the Commodity Channel Index (CCI) is below -100 (indicating an oversold condition) and the 14-day RSI crosses above 50 in a bullish market. Set sell conditions for when the CCI is above 100 (indicating an overbought condition) and the RSI falls below 50."
      },
      {
        "question": "Design a trading strategy that triggers a buy signal when the Average Directional Index (ADX) is above 25, indicating a strong trend, and the +DI line crosses above the -DI line during a bullish market. Define sell conditions for when the ADX is above 25 and the +DI line crosses below the -DI line."
      },
      {
        "question": "Formulate a strategy to buy when the Williams %R is below -80 (indicating an oversold condition) and the Money Flow Index (MFI) is above 50, indicating buying pressure during a market correction. Set sell conditions for when the Williams %R is above -20 (indicating an overbought condition) and the MFI falls below 50."
      },
      {
        "question": "Formulate a strategy that issues a buy order when the Stochastic Oscillator shows a value below 20 (indicating an oversold condition) and the Average True Range (ATR) indicates increasing volatility during a market recovery. Define sell conditions for when the Stochastic Oscillator shows a value above 80 (indicating an overbought condition) and the ATR indicates decreasing volatility."
      },
      {
        "question": "Develop a strategy that triggers a buy signal when the Parabolic SAR indicates an uptrend and the Chaikin Money Flow (CMF) is above zero, indicating buying pressure in a bullish market. Define sell conditions for when the Parabolic SAR indicates a downtrend and the CMF is below zero, indicating selling pressure."
      },
      {
        "question": "Develop a trading strategy that initiates a buy order when the 20-day Simple Moving Average (SMA) crosses above the 50-day Simple Moving Average (SMA) and the Relative Strength Index (RSI) is above 50 during a bullish market. Define sell conditions when the 20-day SMA crosses below the 50-day SMA and the RSI falls below 50."
      }
    ],
    "signature_instructions": "\nYou are a python developer that intent to make a workable trading strategy. Your tasks are :\n- Create a `CustomIndicator` class that inherit from the `Indicator` class\n- Create a `BackTestStrategy` class that inherit from the `BaseStrategy` class and modify the `execute` function to follow human requirements.\nNote : You MUST STRICTLY follow the instructions above.\nHere is the `BaseStrategy` class : \n```python\nimport backtrader as bt\n# Define a base strategy class for handling buy and sell signals and order notifications.\nclass BaseStrategy(bt.Strategy):\n    def __init__(self, debug=True):\n        \"\"\"\n        Initialize the strategy with parameters.\n\n        Args:\n        - debug (bool): If True, enable debug logging.\n        \n        Attributes:\n        - countBuy (int): Counter for buy signals.\n        - countSell (int): Counter for sell signals.\n        - final_signal (int or None): Final signal for trading: 1 (long), 0 (neutral), -1 (sell).\n        - debug (bool): Flag for debug mode.\n        \"\"\"\n        self.countBuy = 0\n        self.countSell = 0\n        self.final_signal = None\n        self.debug = debug\n\n    def log(self, txt, dt=None):\n        \"\"\"\n        Logging function for displaying strategy events.\n\n        Args:\n        - txt (str): Text message to log.\n        - dt (datetime, optional): Date and time of the log event.\n        \"\"\"\n        if self.debug:\n            dt_day = self.datas[0].datetime.date(0)\n            dt_value = dt or self.datas[0].datetime.time(0)\n            print(\"%sT%s, %s\" % (dt_day, dt_value.isoformat(), txt))\n\n    def notify_order(self, order):\n        \"\"\"\n        Notify when an order status changes.\n\n        Args:\n        - order (backtrader.Order): Order object containing order details.\n        \"\"\"\n        if order.status in [order.Submitted, order.Accepted]:\n            return  # Ignore submitted\/accepted orders\n\n        if order.status == order.Completed:\n            if order.isbuy():\n                if self.countSell > 0:\n                    info_trade = \"CLOSE SELL\"\n                    self.countSell -= 1\n                else:\n                    info_trade = \"BUY EXECUTED\"\n                    self.countBuy += 1\n                self.log(\n                    f\"{info_trade}, Price: %.2f, Cost: %.2f, Comm %.2f\"\n                    % (\n                        order.executed.price,\n                        order.executed.value,\n                        order.executed.comm,\n                    )\n                )\n            else:  # Sell order executed\n                if self.countBuy > 0:\n                    info_trade = \"CLOSE BUY\"\n                    self.countBuy -= 1\n                else:\n                    info_trade = \"SELL EXECUTED\"\n                    self.countSell += 1\n                self.log(\n                    f\"{info_trade}, Price: %.2f, Cost: %.2f, Comm %.2f\"\n                    % (\n                        order.executed.price,\n                        order.executed.value,\n                        order.executed.comm,\n                    )\n                )\n\n            self.bar_executed = len(self)\n\n        elif order.status in [order.Canceled, order.Margin, order.Rejected]:\n            self.log(\"Order Canceled\/Margin\/Rejected\")\n\n        self.order = None  # Reset the order attribute\n\n    def execute(self) -> int:\n        \"\"\"\n        Placeholder for executing trading logic.\n\n        Returns:\n        - int: Trading signal: 1 (long), 0 (neutral), -1 (sell), or None if no signal.\n        \"\"\"\n        raise NotImplementedError\n\n    def next(self):\n        \"\"\"\n        Execute trading decisions based on the final signal generated by `execute()`.\n        \"\"\"\n        self.final_signal = self.execute()\n        if self.final_signal is None:\n            return\n\n        if self.final_signal > 0:  # Long signal\n            if self.position:\n                if self.countSell:\n                    self.order = self.close()  # Close sell position if counter is set\n            else:\n                self.order = self.buy()  # Open buy position\n\n        elif self.final_signal < 0:  # Short signal\n            if self.position:\n                if self.countBuy:\n                    self.order = self.close()  # Close buy position if counter is set\n            else:\n                self.order = self.sell()  # Open sell position\n\n```\n\nHere is the examples using price volume trend indicator :\n```python\nimport backtrader as bt\nclass PVT(bt.Indicator):\n    lines = ('pvt',)\n    params = (('period', 1),)\n\n    def init(self):\n        self.addminperiod(self.params.period)\n\n    def next(self):\n        if len(self) == 1:\n            self.lines.pvt[0] = 0  # Initialize PVT at the beginning\n        else:\n            prev_close = self.data.close[-1]\n            current_close = self.data.close[0]\n            volume = self.data.volume[0]\n            self.lines.pvt[0] = self.lines.pvt[-1] + ((current_close - prev_close) \/ prev_close) * volume\n\n#Define a specific strategy using the custom PVT indicator\nclass BackTestStrategy(BaseStrategy):\n    def init(self, *args, **kwargs):\n        super().init(*args, **kwargs)\n        # Initialize the PVT indicator\n        self.pvt = PVT()\n\n\n    def execute(self):\n        \"\"\"\n        Define the trading logic based on the PVT indicator.\n\n        Returns:\n        \n        int: Trading signal: 1 (long), -1 (sell), or None if no signal.\"\"\"\n        if self.pvt[0] > self.pvt[-1]:  # Example logic: if PVT is increasing\n          return 1  # Long signal\n        elif self.pvt[0] < self.pvt[-1]:  # Example logic: if PVT is decreasing\n          return -1  # Short signal\n        return None  # No signal```\n\n",
    "signature_prefix": "Answer:"
  }
}
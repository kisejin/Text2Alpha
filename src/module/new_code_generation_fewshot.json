{
  "generate_result": {
    "lm": null,
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "question": "Formulate a strategy to buy when the Gann Angles indicate support at a key level and the 14-day RSI is above 50 during a bullish market. Define sell conditions for when the Gann Angles indicate resistance at a key level and the RSI falls below 50.",
        "feedback": "\n    You encountered an error from the package `ERROR MESSEAGE`: `IndexError: array index out of range` at `Function name: __getitem__, params: {'ago': 0}`. \n    \n    This error originates from the code in your function \n Function name: next, params: {}\nThe error occurs at `Line: 23,` of your code answer. The code should not contain this error. \n    Please retry with the following description.\"\n    \n\n        The code must avoid the AttributeError: 'float' object has no attribute 'copy'. This error occurs in the following function:\n Function name: next, params: {'delta': 0.80999755859375}\nError location: Line: 28, \n\n    You encountered an error from the package `ERROR MESSEAGE`: `TypeError: must be real number, not LinesOperation` at `Function name: __setitem__, params: {'ago': 0, 'value': '<backtrader.linebuffer.LinesOper...'}`. \n    \n    This error originates from the code in your function \n Function name: next, params: {'delta': 0.80999755859375, 'up': array(0.80999756), 'down': array(0.), 'roll_up': '<backtrader.indicators.basicops....', 'roll_down': '<backtrader.indicators.basicops....', 'rs': '<backtrader.linebuffer.LinesOper...'}\nThe error occurs at `Line: 34,` of your code answer. The code should not contain this error. \n    Please retry with the following description.\"\n    \n\n        The code must avoid the ZeroDivisionError: float division by zero. This error occurs in the following function:\n Function name: next, params: {'delta': 0.80999755859375}\nError location: Line: 38, \nPlease review and correct the formulas and conditions. Make sure the strategy includes at least one buy and one sell signal.",
        "answer": "```python\nimport backtrader as bt\nimport math\nimport numpy as np\n\nclass GannAngle(bt.Indicator):\n    lines = (\"angle\",)\n    params = ((\"period\", 1),)\n\n    def __init__(self):\n        self.addminperiod(self.params.period)\n\n    def next(self):\n        if len(self) > 1:\n            high, low, close = self.data.high[-1], self.data.low[-1], self.data.close[-1]\n            if close != 0:\n                self.lines.angle[0] = math.atan((high - low) \/ close) * (180 \/ math.pi)\n            else:\n                self.lines.angle[0] = 0\n        else:\n            self.lines.angle[0] = 0\n\nclass RSI(bt.Indicator):\n    lines = (\"rsi\",)\n    params = ((\"period\", 14),)\n\n    def __init__(self):\n        self.addminperiod(self.params.period)\n        self.up, self.down = 0, 0\n        self.roll_up, self.roll_down = 0, 0\n\n    def next(self):\n        delta = self.data.close[0] - self.data.close[-1]\n        if delta > 0:\n            self.up = delta\n            self.down = 0\n        else:\n            self.up = 0\n            self.down = -delta\n        if len(self) > self.params.period:\n            self.roll_up = self.roll_up * (self.params.period - 1) \/ self.params.period + self.up\n            self.roll_down = self.roll_down * (self.params.period - 1) \/ self.params.period + self.down\n        else:\n            self.roll_up += self.up\n            self.roll_down += self.down\n        if self.roll_down != 0:\n            rs = self.roll_up \/ self.roll_down\n            self.lines.rsi[0] = 100 - (100 \/ (1 + rs))\n        else:\n            self.lines.rsi[0] = 100\n\nclass BackTestStrategy(BaseStrategy):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.gann_angle = GannAngle()\n        self.rsi = RSI()\n\n    def execute(self):\n        if len(self) > 1:\n            if self.gann_angle[0] > 45 and self.rsi[0] > 50:\n                return 1\n            elif self.gann_angle[0] < 45 and self.rsi[0] < 50:\n                return -1\n        return None\n```",
        "num_retry": 5
      },
      {
        "question": "Create a trading strategy that initiates a buy order when the Donchian Channels show a price breakout above the upper channel and the Aroon Up indicator crosses above the Aroon Down indicator during a bullish market. Define sell conditions for when the price falls below the lower Donchian Channel and the Aroon Up indicator crosses below the Aroon Down indicator."
      },
      {
        "question": "Design a trading strategy that triggers a buy signal when the Directional Movement Index (DMI) shows +DI above -DI and the Price Rate of Change (Price ROC) is positive during a bullish market. Define sell conditions for when the DMI shows +DI below -DI and the Price ROC turns negative."
      },
      {
        "question": "Design a trading strategy that triggers a buy signal when the Accumulation\/Distribution Line (A\/D Line) trends upwards and the Elder-Ray Index shows Bull Power above zero in a bullish market. Define sell conditions for when the A\/D Line trends downwards and the Elder-Ray Index shows Bear Power above zero."
      },
      {
        "question": "Formulate a strategy to buy when the Pivot Points indicate support levels holding strong and the Rate of Change (ROC) is positive, indicating bullish momentum during a market uptrend. Define sell conditions for when the Pivot Points indicate resistance levels being tested and the ROC turns negative."
      },
      {
        "question": "Develop a strategy to buy when the Stochastic Oscillator shows a value below 20 (indicating an oversold condition) and the Aroon Up indicator crosses above the Aroon Down indicator during a market recovery. Set sell conditions for when the Stochastic Oscillator shows a value above 80 (indicating an overbought condition) and the Aroon Up indicator crosses below the Aroon Down indicator."
      },
      {
        "question": "Formulate a strategy that issues a buy order when the Stochastic Oscillator shows a value below 20 (indicating an oversold condition) and the Average True Range (ATR) indicates increasing volatility during a market recovery. Define sell conditions for when the Stochastic Oscillator shows a value above 80 (indicating an overbought condition) and the ATR indicates decreasing volatility."
      },
      {
        "question": "Create a trading strategy that initiates a buy order when the 20-day SMA crosses above the 50-day SMA and the ADX is above 25, indicating a strong trend during a bullish market. Define sell conditions for when the 20-day SMA crosses below the 50-day SMA and the ADX falls below 25."
      },
      {
        "question": "Create a trading strategy that triggers a buy signal when the Moving Average Convergence Divergence (MACD) line crosses above the signal line and the Bollinger Bands show a price break above the upper band in a bullish market. Set sell conditions for when the MACD line crosses below the signal line and the price falls below the lower Bollinger Band."
      },
      {
        "question": "Formulate a strategy to buy when the Coppock Curve is rising, indicating bullish momentum, and the McClellan Oscillator is positive during a market uptrend. Set sell conditions for when the Coppock Curve is falling and the McClellan Oscillator is negative."
      },
      {
        "question": "Design a trading strategy that triggers a buy signal when the McClellan Summation Index is rising, indicating bullish momentum, and the Relative Vigor Index (RVI) is above zero during a market uptrend. Define sell conditions for when the McClellan Summation Index is falling and the RVI is below zero."
      },
      {
        "question": "Formulate a strategy to buy when the Heikin-Ashi candlesticks indicate bullish momentum and the 20-day EMA crosses above the 50-day EMA during a market uptrend. Define sell conditions for when the Heikin-Ashi candlesticks indicate bearish momentum and the 20-day EMA crosses below the 50-day EMA."
      },
      {
        "question": "Design a trading strategy that triggers a buy signal when the Fibonacci Retracement level of 50% is tested and the CCI is below -100 (indicating an oversold condition) during a market correction. Define sell conditions for when the Fibonacci Extension level of 161.8% is reached and the CCI is above 100 (indicating an overbought condition)."
      },
      {
        "question": "Design a trading strategy that triggers a buy signal when the Average Directional Index (ADX) is above 25, indicating a strong trend, and the +DI line crosses above the -DI line during a bullish market. Define sell conditions for when the ADX is above 25 and the +DI line crosses below the -DI line."
      },
      {
        "question": "Create a trading strategy that initiates a buy order when the On-Balance Volume (OBV) trends upwards and the 10-day Exponential Moving Average (EMA) crosses above the 30-day EMA during a bullish market. Define sell conditions for when the OBV trends downwards and the 10-day EMA crosses below the 30-day EMA."
      },
      {
        "question": "Design a trading strategy to buy when the Commodity Channel Index (CCI) is below -100 (indicating an oversold condition) and the 14-day RSI crosses above 50 in a bullish market. Set sell conditions for when the CCI is above 100 (indicating an overbought condition) and the RSI falls below 50."
      }
    ],
    "signature_instructions": "\nYou are a python developer that intent to make a workable trading strategy. Your tasks are :\n- Create a `CustomIndicator` class that inherit from the `Indicator` class\n- Create a `BackTestStrategy` class that inherit from the `BaseStrategy` class and modify the `execute` function to follow human requirements.\nNote : You MUST STRICTLY follow the instructions above.\nHere is the `BaseStrategy` class : \n```python\nimport backtrader as bt\n\n\n# Define a base strategy class for handling buy and sell signals and order notifications.\nclass BaseStrategy(bt.Strategy):\n    def __init__(self, debug=True):\n        \"\"\"\n        Initialize the strategy with parameters.\n\n        Args:\n        - debug (bool): If True, enable debug logging.\n\n        Attributes:\n        - countBuy (int): Counter for buy signals.\n        - countSell (int): Counter for sell signals.\n        - final_signal (int or None): Final signal for trading: 1 (long), 0 (neutral), -1 (sell).\n        - debug (bool): Flag for debug mode.\n        \"\"\"\n        self.countBuy = 0\n        self.countSell = 0\n        self.final_signal = None\n        self.debug = debug\n        self.cbuy = 0\n        self.csell = 0\n\n    def log(self, txt, dt=None):\n        \"\"\"\n        Logging function for displaying strategy events.\n\n        Args:\n        - txt (str): Text message to log.\n        - dt (datetime, optional): Date and time of the log event.\n        \"\"\"\n        if self.debug:\n            dt_day = self.datas[0].datetime.date(0)\n            dt_value = dt or self.datas[0].datetime.time(0)\n            print(\"%sT%s, %s\" % (dt_day, dt_value.isoformat(), txt))\n\n    def notify_order(self, order):\n        \"\"\"\n        Notify when an order status changes.\n\n        Args:\n        - order (backtrader.Order): Order object containing order details.\n        \"\"\"\n        if order.status in [order.Submitted, order.Accepted]:\n            return  # Ignore submitted\/accepted orders\n\n        if order.status == order.Completed:\n            if order.isbuy():\n                if self.countSell > 0:\n                    info_trade = \"CLOSE SELL\"\n                    self.countSell -= 1\n                else:\n                    info_trade = \"BUY EXECUTED\"\n                    self.countBuy += 1\n                self.log(\n                    f\"{info_trade}, Price: %.2f, Cost: %.2f, Comm %.2f\"\n                    % (\n                        order.executed.price,\n                        order.executed.value,\n                        order.executed.comm,\n                    )\n                )\n            else:  # Sell order executed\n                if self.countBuy > 0:\n                    info_trade = \"CLOSE BUY\"\n                    self.countBuy -= 1\n                else:\n                    info_trade = \"SELL EXECUTED\"\n                    self.countSell += 1\n                self.log(\n                    f\"{info_trade}, Price: %.2f, Cost: %.2f, Comm %.2f\"\n                    % (\n                        order.executed.price,\n                        order.executed.value,\n                        order.executed.comm,\n                    )\n                )\n\n            self.bar_executed = len(self)\n\n        elif order.status in [order.Canceled, order.Margin, order.Rejected]:\n            self.log(\"Order Canceled\/Margin\/Rejected\")\n\n        self.order = None  # Reset the order attribute\n\n    def execute(self) -> int:\n        \"\"\"\n        Placeholder for executing trading logic.\n\n        Returns:\n        - int: Trading signal: 1 (long), 0 (neutral), -1 (sell), or None if no signal.\n        \"\"\"\n        raise NotImplementedError\n\n    def next(self):\n        \"\"\"\n        Execute trading decisions based on the final signal generated by `execute()`.\n        \"\"\"\n        self.final_signal = self.execute()\n        if self.final_signal is None:\n            return\n\n        if self.final_signal > 0:  # Long signal\n            if self.position:\n                if self.countSell:\n                    self.order = (\n                        self.close()\n                    )  # Close sell position if counter is set\n            else:\n                self.order = self.buy()  # Open buy position\n                self.cbuy += 1\n\n        elif self.final_signal < 0:  # Short signal\n            if self.position:\n                if self.countBuy:\n                    self.order = (\n                        self.close()\n                    )  # Close buy position if counter is set\n            else:\n                self.order = self.sell()  # Open sell position\n                self.csell += 1\n\n```\n\nHere is the examples using price volume trend indicator :\n```python\nimport backtrader as bt\n\n\nclass CustomIndicator(bt.Indicator):\n    \"\"\"\"\"\"\n\n    lines = (\"pvt\",)\n    params = ((\"period\", 1),)\n\n    def init(self):\n        self.addminperiod(self.params.period)\n\n    def next(self):\n        if len(self) == 1:\n            self.lines.pvt[0] = 0  # Initialize PVT at the beginning\n        else:\n            prev_close = self.data.close[-1]\n            current_close = self.data.close[0]\n            volume = self.data.volume[0]\n            self.lines.pvt[0] = (\n                self.lines.pvt[-1]\n                + ((current_close - prev_close) \/ prev_close) * volume\n            )\n\n\n# Define a specific strategy using the custom PVT indicator\nclass BackTestStrategy(BaseStrategy):\n    def init(self, *args, **kwargs):\n        super().init(*args, **kwargs)\n        # Initialize the PVT indicator\n        self.pvt = PVT()\n\n    def execute(self):\n        \"\"\"\n        Define the trading logic based on the PVT indicator.\n\n        Returns:\n\n        int: Trading signal: 1 (long), -1 (sell), or None if no signal.\"\"\"\n        if self.pvt[0] > self.pvt[-1]:  # Example logic: if PVT is increasing\n            return 1  # Long signal\n        elif self.pvt[0] < self.pvt[-1]:  # Example logic: if PVT is decreasing\n            return -1  # Short signal\n        return None  # No signal\n```\n\n",
    "signature_prefix": "Answer:"
  }
}